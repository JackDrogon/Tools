#!/bin/bash

# This script is used to backup rootfs to a btrfs subvolume by creating a new snapshot and send to nas
# The snapshot is created by the following steps:
# 1. mount rootfs
# 2. create snapshot
# 3. send snapshot to nas
# 3.1 every month create a full backup
# 3.2 every day create an incremental backup
# 4. delete old snapshots
# 5. unmount rootfs

#===============================================================================
# Configuration Section
#===============================================================================

# Script metadata
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_DESCRIPTION="Btrfs root filesystem backup utility"

# Paths and mount points
readonly ROOT_MOUNTPOINT="/mnt"
readonly SNAPSHOT_DIR="${ROOT_MOUNTPOINT}/.snapshots"
readonly SUBVOLUME_NAME="ubuntu"
readonly REMOTE_BACKUP_PATH="/mnt/data/Data/Backup/CM/RootFS/btrfs"
readonly REMOTE_USER="drogon"
readonly REMOTE_HOST="nas.local"

# Get root device dynamically
readonly ROOT_DEVICE="$(df / | sed '1d' | awk '{print $NR}')"

# Backup configuration
readonly SNAPSHOTS_TO_KEEP=3
readonly FULL_BACKUP_MONTH_INTERVAL=1  # Create full backup every month
readonly SLEEP_AFTER_SNAPSHOT=3        # Seconds to wait after creating snapshot

#===============================================================================
# Logging System
#===============================================================================

# Log levels
readonly LOG_LEVEL_DEBUG=0
readonly LOG_LEVEL_INFO=1
readonly LOG_LEVEL_WARN=2
readonly LOG_LEVEL_ERROR=3

# Current log level (default: INFO)
LOG_LEVEL=${LOG_LEVEL_INFO}

# Log file
readonly LOG_FILE="/var/log/${SCRIPT_NAME}.log"
readonly LOG_FILE_ENABLED=true

# Logging functions
log() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local level_name=""

    case $level in
        $LOG_LEVEL_DEBUG) level_name="DEBUG" ;;
        $LOG_LEVEL_INFO)  level_name="INFO"  ;;
        $LOG_LEVEL_WARN)  level_name="WARN"  ;;
        $LOG_LEVEL_ERROR) level_name="ERROR" ;;
    esac

    # Only log if level is >= current log level
    if [ $level -ge $LOG_LEVEL ]; then
        local log_message="[$timestamp] [$level_name] $message"
        echo "$log_message" >&2

        # Write to log file if enabled
        if [ "$LOG_FILE_ENABLED" = true ] && [ -w "$(dirname "$LOG_FILE")" ]; then
            echo "$log_message" >> "$LOG_FILE"
        fi
    fi
}

# Convenience logging functions
debug() { log $LOG_LEVEL_DEBUG "$1"; }
info()  { log $LOG_LEVEL_INFO  "$1"; }
warn()  { log $LOG_LEVEL_WARN  "$1"; }
error() { log $LOG_LEVEL_ERROR "$1"; }

#===============================================================================
# Error Handling
#===============================================================================

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_ERROR_MOUNT=10
readonly EXIT_ERROR_SNAPSHOT=20
readonly EXIT_ERROR_SEND=30
readonly EXIT_ERROR_DELETE=40
readonly EXIT_ERROR_UMOUNT=50
readonly EXIT_ERROR_VALIDATION=60

# Error handler
error_exit() {
    local exit_code=$1
    local message=$2
    error "$message"
    exit $exit_code
}

# Command execution with error handling
safe_exec() {
    local description=$1
    shift

    debug "Executing: $*"
    if ! "$@"; then
        error_exit $EXIT_ERROR "Failed to $description"
    fi
}

#===============================================================================
# Observability and Metrics
#===============================================================================

# Metrics
SCRIPT_START_TIME=""
METRICS_TRANSFER_TIME=0
METRICS_TOTAL_SNAPSHOTS=0
METRICS_DELETED_SNAPSHOTS=0

# Initialize metrics
init_metrics() {
    SCRIPT_START_TIME=$(date +%s)
    debug "Metrics initialized"
}

# Print final metrics
print_metrics() {
    local end_time=$(date +%s)
    local total_time=$((end_time - SCRIPT_START_TIME))

    info "=== Backup Metrics ==="
    info "Total execution time: ${total_time}s"
    info "Transfer time: ${METRICS_TRANSFER_TIME}s"
    info "Total snapshots before cleanup: ${METRICS_TOTAL_SNAPSHOTS}"
    info "Deleted snapshots: ${METRICS_DELETED_SNAPSHOTS}"
}

#===============================================================================
# Validation Functions
#===============================================================================

# Check if running as root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        error_exit $EXIT_ERROR_VALIDATION "This script must be run as root"
    fi
}

# Check prerequisites
check_prerequisites() {
    local required_commands=("btrfs" "ssh" "df" "mount" "umount" "date")

    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            error_exit $EXIT_ERROR_VALIDATION "Required command '$cmd' not found"
        fi
    done

    # Check if btrfs is available
    if ! btrfs --help &> /dev/null; then
        error_exit $EXIT_ERROR_VALIDATION "Btrfs tools not available"
    fi
}

# Check if root device is valid
validate_root_device() {
    if [ -z "$ROOT_DEVICE" ]; then
        error_exit $EXIT_ERROR_VALIDATION "Cannot determine root device"
    fi

    if [ ! -e "$ROOT_DEVICE" ]; then
        error_exit $EXIT_ERROR_VALIDATION "Root device '$ROOT_DEVICE' does not exist"
    fi
}

# Check mountpoint availability
check_mountpoint() {
    if [ -"$ROOT_MOUNTPOINT" = "/" ]; then
        error_exit $EXIT_ERROR_VALIDATION "Mountpoint cannot be root filesystem"
    fi

    # Create mountpoint if it doesn't exist
    if [ ! -d "$ROOT_MOUNTPOINT" ]; then
        info "Creating mountpoint: $ROOT_MOUNTPOINT"
        mkdir -p "$ROOT_MOUNTPOINT"
    fi
}

#===============================================================================
# Core Functions
#===============================================================================

# Mount root filesystem
mount_rootfs() {
    info "Mounting root filesystem from $ROOT_DEVICE to $ROOT_MOUNTPOINT"

    # Check if already mounted
    if mountpoint -q "$ROOT_MOUNTPOINT"; then
        warn "Mountpoint $ROOT_MOUNTPOINT is already mounted"
        return 0
    fi

    safe_exec "mount root filesystem" sudo mount "$ROOT_DEVICE" "$ROOT_MOUNTPOINT"
    info "Root filesystem mounted successfully"
}

# Create snapshot
create_snapshot() {
    local datetime=$(date +'%Y%m%d%H%M')
    local snapshot_name="${SNAPSHOT_DIR}/${SUBVOLUME_NAME}-${datetime}"
    local source_volume="${ROOT_MOUNTPOINT}/@${SUBVOLUME_NAME}"

    info "Creating snapshot: $snapshot_name"
    debug "Source volume: $source_volume"

    # Create snapshot directory if it doesn't exist
    if [ ! -d "$SNAPSHOT_DIR" ]; then
        debug "Creating snapshot directory: $SNAPSHOT_DIR"
        mkdir -p "$SNAPSHOT_DIR"
    fi

    # Create readonly snapshot
    safe_exec "create snapshot" sudo btrfs subvolume snapshot -r "$source_volume" "$snapshot_name"

    info "Snapshot created successfully"

    # Store snapshot name for later use
    echo "$snapshot_name" > /tmp/backup_rootfs_latest_snapshot

    # Sleep to ensure snapshot is committed
    sleep $SLEEP_AFTER_SNAPSHOT
}

# Get latest snapshot path
get_latest_snapshot() {
    if [ -f /tmp/backup_rootfs_latest_snapshot ]; then
        cat /tmp/backup_rootfs_latest_snapshot
    else
        error_exit $EXIT_ERROR_SNAPSHOT "Cannot find latest snapshot path"
    fi
}

# Send incremental snapshot to NAS
send_incremental_snapshot() {
    local snapshot_name=$(get_latest_snapshot)
    local snapshot_subvol=".snapshots/${SUBVOLUME_NAME}"

    info "Sending incremental snapshot to NAS"

    # Find parent snapshot
    local parent_snapshot=$(sudo btrfs subvolume list "$ROOT_MOUNTPOINT" |
                           grep "$snapshot_subvol" |
                           awk '{print $NF}' |
                           sort |
                           tail -2 |
                           head -1)

    if [ -z "$parent_snapshot" ]; then
        error "Cannot find parent snapshot for incremental backup"
        return 1
    fi

    local full_parent_path="${ROOT_MOUNTPOINT}/${parent_snapshot}"
    local parent_date=$(echo "$parent_snapshot" | awk -F '-' '{print $NF}')
    local datetime=$(date +'%Y%m%d%H%M')
    local remote_path="${REMOTE_BACKUP_PATH}/incremental_${SUBVOLUME_NAME}_${parent_date}-${datetime}.img"

    debug "Parent snapshot: $full_parent_path"
    debug "Remote path: $remote_path"

    local start_time=$(date +%s)
    safe_exec "send incremental snapshot" \
        sudo btrfs send -p "$full_parent_path" "$snapshot_name" | \
        ssh "${REMOTE_USER}@${REMOTE_HOST}" "cat > $remote_path"
    METRICS_TRANSFER_TIME=$(($(date +%s) - start_time))

    info "Incremental snapshot sent successfully in ${METRICS_TRANSFER_TIME}s"
}

# Send full snapshot to NAS
send_full_snapshot() {
    local snapshot_name=$(get_latest_snapshot)
    local datetime=$(date +'%Y%m%d%H%M')
    local remote_path="${REMOTE_BACKUP_PATH}/snapshot_${SUBVOLUME_NAME}_${datetime}.img"

    info "Sending full snapshot to NAS"
    debug "Remote path: $remote_path"

    local start_time=$(date +%s)
    safe_exec "send full snapshot" \
        sudo btrfs send "$snapshot_name" | \
        ssh "${REMOTE_USER}@${REMOTE_HOST}" "cat > $remote_path"
    METRICS_TRANSFER_TIME=$(($(date +%s) - start_time))

    info "Full snapshot sent successfully in ${METRICS_TRANSFER_TIME}s"
}

# Determine backup strategy
determine_backup_strategy() {
    local force_full=$1

    if [ "$force_full" = "true" ]; then
        info "Force full backup requested"
        echo "full"
        return
    fi

    # Count existing snapshots
    local snapshot_count=$(ls -ad "$SNAPSHOT_DIR/${SUBVOLUME_NAME}"-* 2>/dev/null | wc -l)
    METRICS_TOTAL_SNAPSHOTS=$snapshot_count

    if [ "$snapshot_count" -eq 0 ]; then
        info "No existing snapshots found, will create full backup"
        echo "full"
    elif [ "$snapshot_count" -eq 1 ]; then
        info "Only one snapshot exists, will create full backup"
        echo "full"
    else
        # Check if we need monthly full backup
        local latest_month=$(ls -ad "$SNAPSHOT_DIR/${SUBVOLUME_NAME}"-* |
                            sort -r |
                            awk 'NR==2 {print $NF}' |
                            awk -F '-' '{print $NF}' |
                            cut -c 5-6)
        local current_month=$(date +'%m')

        if [ "$latest_month" != "$current_month" ]; then
            info "Month changed, will create full backup"
            echo "full"
        else
            info "Will create incremental backup"
            echo "incremental"
        fi
    fi
}

# Send snapshot to NAS
send_snapshot() {
    local force_full=$1
    local strategy=$(determine_backup_strategy "$force_full")

    case "$strategy" in
        full)
            send_full_snapshot
            ;;
        incremental)
            if ! send_incremental_snapshot; then
                warn "Incremental backup failed, falling back to full backup"
                send_full_snapshot
            fi
            ;;
    esac
}

# Delete old snapshots
cleanup_snapshots() {
    info "Cleaning up old snapshots (keeping $SNAPSHOTS_TO_KEEP)"

    # Get list of snapshots to delete
    local snapshots_to_delete=$(sudo btrfs subvolume list "$ROOT_MOUNTPOINT" |
                               grep ".snapshots/${SUBVOLUME_NAME}" |
                               awk '{print $NF}' |
                               sort -r |
                               tail -n +$((SNAPSHOTS_TO_KEEP + 1)))

    if [ -z "$snapshots_to_delete" ]; then
        info "No snapshots to delete"
        return 0
    fi

    local deleted_count=0
    while IFS= read -r snapshot; do
        debug "Deleting snapshot: $snapshot"
        if sudo btrfs subvolume delete -c -v "${ROOT_MOUNTPOINT}/${snapshot}"; then
            ((deleted_count++))
        else
            warn "Failed to delete snapshot: $snapshot"
        fi
    done <<< "$snapshots_to_delete"

    METRICS_DELETED_SNAPSHOTS=$deleted_count
    info "Deleted $deleted_count old snapshots"
}

# Unmount root filesystem
unmount_rootfs() {
    info "Unmounting root filesystem from $ROOT_MOUNTPOINT"

    if ! mountpoint -q "$ROOT_MOUNTPOINT"; then
        warn "Mountpoint $ROOT_MOUNTPOINT is not mounted"
        return 0
    fi

    safe_exec "unmount root filesystem" sudo umount "$ROOT_MOUNTPOINT"
    info "Root filesystem unmounted successfully"
}

#===============================================================================
# Command Line Interface
#===============================================================================

# Print usage
print_usage() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

$SCRIPT_DESCRIPTION

Options:
  -h, --help              Show this help message and exit
  -f, --force-full        Force creation of full snapshot
  --only-create-snapshot  Only create snapshot, don't send to NAS
  -v, --verbose           Enable verbose logging
  -q, --quiet             Suppress non-error output
  --version               Show version information
  --no-cleanup            Don't delete old snapshots
  --dry-run               Show what would be done without executing

Examples:
  $SCRIPT_NAME                    # Create incremental backup (or full if needed)
  $SCRIPT_NAME -f                 # Force full backup
  $SCRIPT_NAME --only-create-snapshot  # Only create local snapshot
  $SCRIPT_NAME -v                 # Verbose output
  $SCRIPT_NAME --dry-run          # Show planned actions

Exit Codes:
  0  Success
  10 Mount error
  20 Snapshot error
  30 Send error
  40 Delete error
  50 Unmount error
  60 Validation error

Report bugs to: <your-email@example.com>
EOF
}

# Print version
print_version() {
    echo "$SCRIPT_NAME version $SCRIPT_VERSION"
    echo "Btrfs root filesystem backup utility"
}

#===============================================================================
# Main Orchestration
#===============================================================================

# Main function
main() {
    local force_full=false
    local only_create_snapshot=false
    local dry_run=false
    local no_cleanup=false

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                print_usage
                exit $EXIT_SUCCESS
                ;;
            --version)
                print_version
                exit $EXIT_SUCCESS
                ;;
            -f|--force-full)
                force_full=true
                shift
                ;;
            --only-create-snapshot)
                only_create_snapshot=true
                shift
                ;;
            -v|--verbose)
                LOG_LEVEL=$LOG_LEVEL_DEBUG
                shift
                ;;
            -q|--quiet)
                LOG_LEVEL=$LOG_LEVEL_ERROR
                shift
                ;;
            --no-cleanup)
                no_cleanup=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                print_usage
                exit $EXIT_ERROR_VALIDATION
                ;;
        esac
    done

    # Initialize
    info "Starting $SCRIPT_NAME v$SCRIPT_VERSION"
    init_metrics

    # Dry run mode
    if [ "$dry_run" = true ]; then
        warn "DRY RUN MODE: No actual changes will be made"
        LOG_LEVEL=$LOG_LEVEL_DEBUG
    fi

    # Validation
    check_prerequisites
    validate_root_device
    check_mountpoint

    # Main workflow
    if [ "$dry_run" = true ]; then
        info "Would execute: mount_rootfs"
        info "Would execute: create_snapshot"
        if [ "$only_create_snapshot" = false ]; then
            info "Would execute: send_snapshot (force_full=$force_full)"
            [ "$no_cleanup" = false ] && info "Would execute: cleanup_snapshots"
        fi
        info "Would execute: unmount_rootfs"
    else
        # Execute backup workflow
        mount_rootfs

        # Create snapshot
        create_snapshot

        # Send to NAS if requested
        if [ "$only_create_snapshot" = false ]; then
            send_snapshot "$force_full"

            # Cleanup old snapshots unless disabled
            if [ "$no_cleanup" = false ]; then
                cleanup_snapshots
            fi
        fi

        # Always unmount
        unmount_rootfs
    fi

    # Cleanup temp file
    rm -f /tmp/backup_rootfs_latest_snapshot

    # Print metrics
    print_metrics

    info "Backup completed successfully"
    exit $EXIT_SUCCESS
}

# Execute main function
main "$@"